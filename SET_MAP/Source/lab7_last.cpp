
//1.11 Словари и множества
/**
Учительница задала Пете домашнее задание — в заданном тексте расставить ударения в словах, после чего поручила Васе проверить это домашнее задание. 
Вася очень плохо знаком с данной темой, поэтому он нашел словарь, в котором указано, как ставятся ударения в словах. 
К сожалению, в этом словаре присутствуют не все слова. Вася решил, что в словах, которых нет в словаре, он будет считать, 
что Петя поставил ударения правильно, если в этом слове Петей поставлено ровно одно ударение.

Оказалось, что в некоторых словах ударение может быть поставлено больше, чем одним способом. 
Вася решил, что в этом случае если то, как Петя поставил ударение, соответствует одному из 
приведенных в словаре вариантов, он будет засчитывать это как правильную расстановку ударения, 
а если не соответствует, то как ошибку.

Вам дан словарь, которым пользовался Вася и домашнее задание, сданное Петей. Ваша задача — определить количество ошибок, которое в этом задании насчитает Вася.

Входные данные

Вводится сначала число N — количество слов в словаре (0 ≤ N ≤ 20000).
Далее идет N строк со словами из словаря. Каждое слово состоит не более чем из 30 символов. 
Все слова состоят из маленьких и заглавных латинских букв. 
В каждом слове заглавная ровно одна буква — та, на которую попадает ударение. 
Слова в словаре расположены в алфавитном порядке. 
Если есть несколько возможностей расстановки ударения в одном и том же слове, 
то эти варианты в словаре идут в произвольном порядке.

Далее идет упражнение, выполненное Петей. 
Упражнение представляет собой строку текста, суммарным объемом не более 300000 символов. 
Строка состоит из слов, которые разделяются между собой ровно одним пробелом. 
Длина каждого слова не превышает 30 символов. Все слова состоят из маленьких и заглавных 
латинских букв (заглавными обозначены те буквы, над которыми Петя поставил ударение). 
Петя мог по ошибке в каком-то слове поставить более одного ударения или не поставить ударения вовсе.

Выходные данные

Выведите количество ошибок в Петином тексте, которые найдет Вася.

Примечание к примеру


1. В слове cannot, согласно словарю возможно два варианта расстановки ударения. 
Эти варианты в словаре могут быть перечислены в любом порядке (т.е. как сначала cAnnot, а потом cannOt, так и наоборот).
Две ошибки, совершенные Петей — это слова be (ударение вообще не поставлено) и fouNd (ударение поставлено неверно). 
Слово thE отсутствует в словаре, но поскольку в нем Петя поставил ровно одно ударение, признается верным.

2. Неверно расставлены ударения во всех словах, кроме The (оно отсутствует в словаре, в нем поставлено ровно одно ударение). 
В остальных словах либо ударные все буквы (в слове PAGE), либо не поставлено ни одного ударения.


Sample Input 1:

4
cAnnot
cannOt
fOund
pAge
thE pAge cAnnot be fouNd
Sample Output 1:

2
Sample Input 2:

4
cAnnot
cannOt
fOund
pAge
The PAGE cannot be found
Sample Output 2:

4
*/

/**
Вариант решения

Вот мой алгоритм на примере первого Примера.

1. Создать "словарь" (set), внести в него слова  (cAnnot, cannOt, fOund, pAge).

2. Создать второй "словарь" (set), внести в него все те же слова, только в нижнем регистре, 
используя функцию tolower (то есть получается cannot, found, page)

3. Далее создаем "Домашнее задание Пети" в виде строки через getline. (thE pAge cAnnot be fouNd)

4. Проверяем не пуста ли строка "Домашнее задание Пети" (можно с помощью функции названиестроки.empty(); 
Если пуста, то можно сразу выводить ответ 0. Если не пуста, то сл.пункт.

5. Далее побуквенно разбираем строку "Домашнее задание Пети", разделяем ее на слова и каждое слово заносим в multiset или в vector. 
Кому как удобнее. (У нас получает множество или вектор, в котором отдельно слова thE, pAge, cAnnot, be, fouNd)

6. Далее проверяем количество заглавных букв в каждом слове "Домашнего задания Пети". 
Если не равно единице, то + ошибка за каждое найденное слово. 
Если равно единице, то сл. пункт. (здесь мы отсеяли лишние слова, в которых есть уже ошибка, 
в нашем случае это - be. Далее работа идет только с оставшимися словами через else)

7. Ищем слово с одним ударением в словаре из пункта 1, если не нашли то сл. пункт. 
(то есть ищем слова thE, pAge, cAnnot, fouNd в словаре, если они найдены то далее работа с ними не идет, 
само собой найдены будут слова pAge и cAnnot, то есть нам осталось определить есть ли ошибки в словах fouNd и thE)

8. Переводим слово в нижний регистр и проверяем есть ли оно в словаре, 
который создали в пункте 2, если оно нашлось, то значит было написано неправильно, соответственно + ошибка. 
(делаем из fouNd - found и проверяем найдется ли он в словаре, в котором все слова в нижем регистре, 
так как оно найдется, то это является ошибкой, так как значит оно записано неправильно, слово thE в словаре не найдется, то есть ошибки нет.)

По итогу в первом примере найдется две ошибки.

Получилось громоздко, на 67 строк, но это работает.
*/

#include <iostream>
#include <string>
#include <sstream> //for istringstream
#include <set>


using namespace std;

int main()
{	
	set <string> dictionaryCapitals, dictinaryNoCapitals;
	multiset <string> stringForCheck;
	int N = 0;
	int cnt = 0; //mistakes counter

	
	//Work with dictionaries
	cin >> N;
	cin.ignore(); //to make "getline" ignore '\n'

	while (N--)
	{
		string sTemp;

		getline(cin, sTemp);

		//making dictionaries
			//make original dictionary with Capitals
			dictionaryCapitals.insert(sTemp);
			//make dictionary without Capitals
			for (int i = 0; i < sTemp.length(); i++) sTemp[i] = tolower(sTemp[i]);
			dictinaryNoCapitals.insert(sTemp);				
	}

	//save input string for checking
	string sTemp;
	string wordForCheck;
		
	getline(cin, sTemp);

	//проверить, что строка не пустая
	if (sTemp.empty()) {
		cout << 0;
		return 0;
	}

	//making set for checking
	istringstream is(sTemp); //create object is for the input stream working (>>)
	while (is >> wordForCheck) {
		stringForCheck.insert(wordForCheck);
	}

	//start checking

	int capitalLetterCnt = 0;
	for (auto now : stringForCheck) {
		for (auto c : now) {
			//check the number of Capital letters in the each word
			if (c >= 'A' && c <= 'Z') capitalLetterCnt++;
		}
		//each word must have one capital letter 
		if (capitalLetterCnt != 1) cnt++;
		else {
			//find words in the original dictionary (with Capitals)			
			//if there is not the word, than find it in the dict. wthout capitals
				if (dictionaryCapitals.find(now) == dictionaryCapitals.end()) {
					//convert Capitals to lower for finding the word in the second dict.
					for (int i = 0; i < now.length(); i++) now[i] = tolower(now[i]);
					if (dictinaryNoCapitals.find(now) != dictinaryNoCapitals.end()) cnt++;
				}			
		}
		
		capitalLetterCnt = 0; //reset capital letters counter
	}

	//print result
	cout << cnt;
	return 0;		
}